<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Best Wordle Strategy — Explore or Exploit | SLC is</title><meta name=description content="Sharpest corner of the IPFS."><link rel=stylesheet href=../../css/simple.css/simple.min.css media=all onload='this.media="all",this.onload=null'></head><body><header><nav><a href=../../>Home</a>
<a href=../../posts/>Posts</a>
<a href=../../music/>Music</a>
<a href=../../about/>About</a></nav><h1>Best Wordle Strategy — Explore or Exploit</h1><i>2022/01/13</i></header><main><article><p><img src=../../images/wordle.webp alt="Wordle Guesses"></p><p>This post will derive an optimal Wordle-specific guessing strategy. The approach taken will be reducing the set of possible words a maximum amount for each guess; however, it doesn&rsquo;t make sense to keep reducing the set of words until the final guess, so we&rsquo;re reintroduced to our old friend, the <a href=https://conceptually.org/concepts/explore-or-exploit>explore-exploit tradeoff</a>.</p><p>The first question we need to answer is, given six guesses, how many should be exploring which consonants and vowels are and aren&rsquo;t present, and how many should exploit that knowledge to guess the word? These two options aren&rsquo;t completely exclusive, but a common problem I see in my own family, is exploring after only the first word and getting stuck in a rut of limited guesses.</p><p>This can be interpreted as an optimization problem: How many guesses maximize the exploration and exploitation value? Meaning, how many guesses should explore the possible letter combinations and how many should use that to guess the word.</p><p>Taking inspiration from the <a href=https://wikipedia.org/wiki/Secretary_problem>Secretary Problem</a>, let&rsquo;s &ldquo;reject&rdquo; the first $\frac{N}{e}$ choices and &ldquo;accept&rdquo; the next best. Simply, let&rsquo;s not consider the first $\frac{6}{e} \approx 2$ guesses toward our exploitation and then try guessing afterwards.</p><p>Another option is to maximize the gradient (<abbr title="Machine Learning">ML</abbr> people get hyped) over word-set size as the exploitation strategy. This would mean that you&rsquo;d stop exploring letters after each following step stops reducing the set size as much.</p><p>This is hand-wavy because I mostly want to dive into the <abbr title="Computer Science">CS</abbr>, but even this can be calculated… I&rsquo;ll maybe do that as well. Instead, I&rsquo;ll see when the letter frequencies plateau and conclude that guessing letters past that point just offer diminishing returns.</p><p>Here&rsquo;s the list of all <a href=../../data/wordles.txt>wordle words</a> as of writing this, though I doubt it&rsquo;ll change much. It might be helpful to have in case you want to run your own tests or follow along.</p><details><summary>Code? Ew Cringe!</summary><p>We&rsquo;ll begin by importing commonly-used packages since it should be highly accessible for anyone. <code>Matplotlib</code> isn&rsquo;t necessary since I show the image, so if you don&rsquo;t have it installed, don&rsquo;t worry.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> matplotlib <span style=color:#f92672>import</span> pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> itertools <span style=color:#f92672>import</span> permutations
</span></span></code></pre></div><p>Now, we just define some helper functions that iterate through the Wordle words and keep track of different patterns.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>letter_distribution</span>(words):
</span></span><span style=display:flex><span>    d <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> words:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> letter <span style=color:#f92672>in</span> word:
</span></span><span style=display:flex><span>            d[letter] <span style=color:#f92672>=</span> d<span style=color:#f92672>.</span>get(letter, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> d
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>letter_placement</span>(words):
</span></span><span style=display:flex><span>    d <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>: {}, <span style=color:#ae81ff>1</span>: {}, <span style=color:#ae81ff>2</span>: {}, <span style=color:#ae81ff>3</span>: {}, <span style=color:#ae81ff>4</span>: {}}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> words:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, letter <span style=color:#f92672>in</span> enumerate(word):
</span></span><span style=display:flex><span>            d[i][letter] <span style=color:#f92672>=</span> d[i]<span style=color:#f92672>.</span>get(letter, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> d
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>score_placement</span>(word, letter_places):
</span></span><span style=display:flex><span>    score <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, letter <span style=color:#f92672>in</span> enumerate(word):
</span></span><span style=display:flex><span>        score <span style=color:#f92672>+=</span> letter_places[i][letter]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> score
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>subset_from_letters</span>(word : str, words : set) <span style=color:#f92672>-&gt;</span> set:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> set(wordle <span style=color:#66d9ef>for</span> wordle <span style=color:#f92672>in</span> words \
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>if</span> set(wordle)<span style=color:#f92672>.</span>issubset(word))
</span></span></code></pre></div><p>Let&rsquo;s open the <code>wordles.txt</code> file and make words a set of all the possible five-letter words.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># map&#39;s lambda takes the first 5 characters of each line</span>
</span></span><span style=display:flex><span><span style=color:#75715e># in wordles.txt, removing the \n character</span>
</span></span><span style=display:flex><span>words <span style=color:#f92672>=</span> set(map(<span style=color:#66d9ef>lambda</span> x: x[:<span style=color:#ae81ff>5</span>], open(<span style=color:#e6db74>&#34;wordles.txt&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>)))
</span></span></code></pre></div><p>To begin determining the best starting word(s), we look at the letter frequencies.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>letter_dist <span style=color:#f92672>=</span> letter_distribution(words)
</span></span><span style=display:flex><span>dist <span style=color:#f92672>=</span> sorted(letter_dist<span style=color:#f92672>.</span>items(), key<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> x: x[<span style=color:#ae81ff>1</span>], reverse<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>bar([x[<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> dist], [y[<span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> dist])
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>show()
</span></span></code></pre></div><p><img src=../../images/wordLetters.webp alt="Letter Distribution"></p><table><thead><tr><th>Letter</th><th style=text-align:right>Count</th></tr></thead><tbody><tr><td>s</td><td style=text-align:right>6665</td></tr><tr><td>e</td><td style=text-align:right>6662</td></tr><tr><td>a</td><td style=text-align:right>5990</td></tr><tr><td>o</td><td style=text-align:right>4438</td></tr><tr><td>r</td><td style=text-align:right>4158</td></tr><tr><td>i</td><td style=text-align:right>3759</td></tr><tr><td>l</td><td style=text-align:right>3371</td></tr><tr><td>t</td><td style=text-align:right>3295</td></tr><tr><td>n</td><td style=text-align:right>2952</td></tr><tr><td>u</td><td style=text-align:right>2511</td></tr><tr><td>d</td><td style=text-align:right>2453</td></tr><tr><td>y</td><td style=text-align:right>2074</td></tr><tr><td>c</td><td style=text-align:right>2028</td></tr><tr><td>p</td><td style=text-align:right>2019</td></tr><tr><td>m</td><td style=text-align:right>1976</td></tr><tr><td>h</td><td style=text-align:right>1760</td></tr><tr><td>g</td><td style=text-align:right>1644</td></tr><tr><td>b</td><td style=text-align:right>1627</td></tr><tr><td>k</td><td style=text-align:right>1505</td></tr><tr><td>f</td><td style=text-align:right>1115</td></tr><tr><td>w</td><td style=text-align:right>1039</td></tr><tr><td>v</td><td style=text-align:right>694</td></tr><tr><td>z</td><td style=text-align:right>434</td></tr><tr><td>j</td><td style=text-align:right>291</td></tr><tr><td>x</td><td style=text-align:right>288</td></tr><tr><td>q</td><td style=text-align:right>112</td></tr></tbody></table><p>Unsurprisingly, the vowels (<code>e</code>, <code>a</code>, <code>o</code>, …, <code>i</code>, <code>u</code>, <code>y</code>?) are highly ranked. What&rsquo;s interesting is that <code>s</code> occurs more than <code>e</code>. Regardless, let&rsquo;s maximize the letters possible on the first guess and search for which words can be made with &ldquo;seaor&rdquo;. While we&rsquo;re at it, let&rsquo;s see what the second and third words are following that same strategy.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(set(word <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> subset_from_letters(<span style=color:#e6db74>&#34;seaor&#34;</span>, words) \
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> len(set(word)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(set(word <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> subset_from_letters(<span style=color:#e6db74>&#34;iltnu&#34;</span>, words) \
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> len(set(word)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(set(word <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> subset_from_letters(<span style=color:#e6db74>&#34;dycpm&#34;</span>, words) \
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> len(set(word)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span>))
</span></span></code></pre></div><blockquote><p>{&lsquo;aeros&rsquo;, &lsquo;arose&rsquo;, &lsquo;soare&rsquo;}
{&lsquo;unlit&rsquo;, &lsquo;until&rsquo;}
{}</p></blockquote><p>Well, we have three choices for the best first word: <code>aeros</code>, <code>arose</code>, and <code>soare</code>. And luckily there are even some second choices: <code>unlit</code>, <code>until</code>.</p><p>What we can do now is compare these options to determine the best. &ldquo;How will one be better than another with the same letters?&rdquo; you might ask. Well, we can now consider letter position. This is moving more toward exploitation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>letter_places <span style=color:#f92672>=</span> letter_placement(words)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>first <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;aeros&#39;</span>, <span style=color:#e6db74>&#39;soare&#39;</span>, <span style=color:#e6db74>&#39;arose&#39;</span>}
</span></span><span style=display:flex><span>second <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;unlit&#39;</span>, <span style=color:#e6db74>&#39;until&#39;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> first:
</span></span><span style=display:flex><span>    print(word, score_placement(word, letter_places))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> second:
</span></span><span style=display:flex><span>    print(word, score_placement(word, letter_places))
</span></span></code></pre></div><table><thead><tr><th>Word</th><th style=text-align:right>Score</th></tr></thead><tbody><tr><td>aeros</td><td style=text-align:right>8219</td></tr><tr><td>soare</td><td style=text-align:right>7138</td></tr><tr><td>arose</td><td style=text-align:right>4708</td></tr><tr><td></td><td style=text-align:right></td></tr><tr><td>unlit</td><td style=text-align:right>2989</td></tr><tr><td>until</td><td style=text-align:right>2506</td></tr></tbody></table><p>As we can see, <a href=https://www.thefreedictionary.com/Aeros>aeros</a> is the best of the three options for our first word. As for our second choice, <a href=https://www.thefreedictionary.com/unlit>unlit</a> is the better than <code>until</code>. All this ranking is doing is seeing if a letter in a certain position is more likely than in a different position.</p><p>If you look at the letter distribution graph, you&rsquo;ll see that the frequencies level out around y-m. This indicates that searching past that point won&rsquo;t result in too many additional words.</p><p>For the sake of completion, we&rsquo;ll search for the final word. However, now we&rsquo;ll need to switch the lowest value characters around until a new second and third word can be arranged.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>exploit_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>letters <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join([letter <span style=color:#66d9ef>for</span> letter, count <span style=color:#f92672>in</span> dist[:exploit_count <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span>]])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> permutations(letters):
</span></span><span style=display:flex><span>    first <span style=color:#f92672>=</span> set(w <span style=color:#66d9ef>for</span> w <span style=color:#f92672>in</span> subset_from_letters(word[:<span style=color:#ae81ff>5</span>], words) \
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> len(set(w)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    second <span style=color:#f92672>=</span> set(w <span style=color:#66d9ef>for</span> w <span style=color:#f92672>in</span> subset_from_letters(word[<span style=color:#ae81ff>5</span>:<span style=color:#ae81ff>10</span>], words) \
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>if</span> len(set(w)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    third <span style=color:#f92672>=</span> set(w <span style=color:#66d9ef>for</span> w <span style=color:#f92672>in</span> subset_from_letters(word[<span style=color:#ae81ff>10</span>:<span style=color:#ae81ff>15</span>], words) \
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> len(set(w)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> first <span style=color:#f92672>and</span> second <span style=color:#f92672>and</span> third:
</span></span><span style=display:flex><span>        print(first, second, third)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span></code></pre></div><blockquote><p>{&lsquo;soare&rsquo;, &lsquo;aeros&rsquo;, &lsquo;arose&rsquo;} {&lsquo;clint&rsquo;} {&lsquo;dumpy&rsquo;}</p></blockquote><p>From this analysis, here&rsquo;s a table to help make the best starting Wordle guesses.</p><table><thead><tr><th>Exploration</th><th>Words</th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>AEROS</td><td></td><td></td></tr><tr><td>2</td><td>AEROS</td><td>UNLIT</td><td></td></tr><tr><td>3</td><td>AEROS</td><td>CLINT</td><td>DUMPY</td></tr></tbody></table></details><h1 id=solution>Solution</h1><p>It was mentioned in a <a href="https://news.ycombinator.com/item?id=29928263#29930961">Hacker News comment</a> that there are actually two lists: one for guessing and another for possible answers. Using this, I updated the best first couple words. I&rsquo;ll also include these, but deriving it is simple with the code above. You can also view updated code as a <a href=../../data/wordleCode.pdf>PDF</a>.</p><table><thead><tr><th>Exploration</th><th>Words</th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>ROATE</td><td></td><td></td></tr><tr><td>2</td><td>ROATE</td><td>PULIS</td><td></td></tr><tr><td>3</td><td>ROATE</td><td>PULIS</td><td>CHYND</td></tr></tbody></table><p>I&rsquo;m sure there are different approaches to determining the best starting word. Some people like the most vowels (in that case use <code>URAEI</code>) while others would prioritize positions (then choose <code>SLATE</code>). I think knocking out the most potential words would help me the most, so that&rsquo;s why I chose this method.</p><p>A benefit of this is that after only two steps of exploration, you have information about ten unique letters. Another step will now put you at fifteen, over half of the alphabet. I hope this comes in handy and you enjoyed the read!</p></article></main><footer><small>Thanks to <a href=https://gohugo.io/>Hugo</a> for building and <a href=https://simplecss.org/>SimpleCSS</a>
for styling
♡</small></footer></body></html>