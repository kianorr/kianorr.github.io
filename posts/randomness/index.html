<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Degrees of Randomness and the Law of Large Numbers | SLC is</title><meta name=description content="Sharpest corner of the IPFS."><link rel=stylesheet href=../../css/simple.css/simple.min.css media=all onload='this.media="all",this.onload=null'></head><body><header><nav><a href=../../>Home</a>
<a href=../../posts/>Posts</a>
<a href=../../music/>Music</a>
<a href=../../about/>About</a></nav><h1>Degrees of Randomness and the Law of Large Numbers</h1><i>2022/02/04</i></header><main><article><p><img src=../../images/randomCoefficients.webp alt="Correlation Coefficient Comparison"></p><p>In a previous post comparing quantum and avalanche diode methods of true random number generation, an interesting pattern emerged. The quantum random numbers would pass more STS tests than avalanche diode random numbers. Seemingly, the quantum RNG converges to a mean before the diode RNG.</p><p>This should not be the case since both methods produce true random numbers, so this post will be exploring if this is actually occurring and why.</p><h2 id=code>Code</h2><p>We&rsquo;ll be using <code>C</code> to do this analysis since it&rsquo;s fast enough for the scale I need.</p><p>The first task will be opening a file of random data by variable amounts. The <a href=https://pubs.opengroup.org/onlinepubs/9699919799/functions/fread.html#tag_16_164>fread</a> command takes a filename and number of bytes to read as arguments, so that&rsquo;ll work well.</p><p>Specifically, the file (let&rsquo;s call it <code>random</code>) needs to be read in incrementing amounts, so the code will look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define MAX_READ 5
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define FILE_NAME &#34;random&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>â€¦</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FILE <span style=color:#f92672>*</span> stream <span style=color:#f92672>=</span> fopen(FILE_NAME, <span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> bytes <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; bytes <span style=color:#f92672>&lt;</span> MAX_READ; bytes<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> buffer[bytes];
</span></span><span style=display:flex><span>	fread(<span style=color:#f92672>&amp;</span>buffer, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span>), bytes, stream);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is storing some number of bytes in a buffer array. Now we can iterate through that array to determine the mean. Keep in mind that the theoretical mean is 0.5, so this is eventually going to compare the rates at which quantum and avalanche diode RNGs converge to the theoretical mean.</p><p>We&rsquo;re iterating through 8 bits at a time, so to find each binary mean, we&rsquo;ll count the number of ones in binary and divide by 8.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>binaryMean</span>(<span style=color:#66d9ef>char</span> byte) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// https://stackoverflow.com/a/698183
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> (byte <span style=color:#f92672>*</span> <span style=color:#ae81ff>01001001001ULL</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>042104210421ULL</span>)
</span></span><span style=display:flex><span>		<span style=color:#f92672>%</span> <span style=color:#ae81ff>017</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8.0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The remainder is just reading multiple files and parsing the data as a <abbr title="Comma-Separated Values">CSV</abbr>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define MAX_READ 1000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>double</span> array[<span style=color:#ae81ff>2</span>][MAX_READ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>float</span> <span style=color:#a6e22e>binaryMean</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> byte) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (byte <span style=color:#f92672>*</span> <span style=color:#ae81ff>01001001001ULL</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>042104210421ULL</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>017</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>8.0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>analyzeFile</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>filename, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> filenum) {
</span></span><span style=display:flex><span>  FILE <span style=color:#f92672>*</span>stream <span style=color:#f92672>=</span> fopen(filename, <span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> bytes <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; bytes <span style=color:#f92672>&lt;=</span> MAX_READ; bytes<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buffer[bytes];
</span></span><span style=display:flex><span>    fread(<span style=color:#f92672>&amp;</span>buffer, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span>), bytes, stream);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>double</span> mean <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> bytes; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      mean <span style=color:#f92672>+=</span> binaryMean(buffer[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    array[filenum][bytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> mean <span style=color:#f92672>/</span> bytes;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  fclose(stream);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  analyzeFile(<span style=color:#e6db74>&#34;../../randomReports/quantum&#34;</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  analyzeFile(<span style=color:#e6db74>&#34;../../randomReports/avalanche&#34;</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Theoretical Mean,Quantum Mean,Avalanche Diode Mean</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> line <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; line <span style=color:#f92672>&lt;</span> MAX_READ; line<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;0.5,%Lf,%Lf</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, array[<span style=color:#ae81ff>0</span>][line], array[<span style=color:#ae81ff>1</span>][line]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The astute among us ðŸ”´ will notice that I&rsquo;m printing the data to stout; however, I&rsquo;ll actually pull a *nix and piping the output to gnuplot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcc -c -o main.o main.c <span style=color:#f92672>&amp;&amp;</span> gcc ./main.o -o main <span style=color:#f92672>&amp;&amp;</span> ./main | cat &gt; /tmp/gnuplotdata.csv <span style=color:#f92672>&amp;&amp;</span> gnuplot -p -e <span style=color:#e6db74>&#34;set title &#39;Quantum vs. Avalanche&#39;;set xlabel &#39;Average Length&#39;;set ylabel &#39;Average&#39;;set datafile separator &#39;,&#39;;plot for [col=1:3] &#39;/tmp/gnuplotdata.csv&#39; using col with lines title columnheader;pause -1&#34;</span>
</span></span></code></pre></div><p>That&rsquo;s <em>sus</em> but why have pipes if you never use them? Anyways, we can now begin comparing convergence.</p><h2 id=analysis>Analysis</h2><p><img src=../../images/quantumAvalanchePlot.webp alt="Gnuplot Mean Convergence Plot"></p><p>This is the plot outputted by gnuplot and it looks like both RNGs converge to 0.5 at equal rates.</p><blockquote><p>The differing rates to randomness is deeper than approaching the mean.</p></blockquote><p>I&rsquo;ll now be using the <a href=https://www.fourmilab.ch/random/>ent</a> tool for statistical testing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>dd <span style=color:#66d9ef>if</span><span style=color:#f92672>=</span>../../randomReports/randomData bs<span style=color:#f92672>=</span><span style=color:#ae81ff>104857601</span> count<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span> iflag<span style=color:#f92672>=</span>fullblock 2&gt;/dev/null | ent -b
</span></span></code></pre></div><details><summary>Quantum</summary><p>Entropy = 1.000000 bits per bit.</p><p>Optimum compression would reduce the size
of this 838860800 bit file by 0 percent.</p><p>Chi square distribution for 838860800 samples is 1.41, and randomly would exceed this value 23.50 percent of the times.</p><p>Arithmetic mean value of data bits is 0.5000 (0.5 = random).</p><p>Monte Carlo value for Pi is 3.141312452 (error 0.01 percent).</p><p>Serial correlation coefficient is -0.000014 (totally uncorrelated = 0.0).</p></details><details><summary>Avalanche Diode</summary><p>Entropy = 1.000000 bits per bit.</p><p>Optimum compression would reduce the size
of this 838860800 bit file by 0 percent.</p><p>Chi square distribution for 838860800 samples is 3.09, and randomly would exceed this value 7.88 percent of the times.</p><p>Arithmetic mean value of data bits is 0.5000 (0.5 = random).</p><p>Monte Carlo value for Pi is 3.141780515 (error 0.01 percent).</p><p>Serial correlation coefficient is -0.000027 (totally uncorrelated = 0.0).</p></details><details><summary>Pseudorandom Generator</summary><p>Entropy = 1.000000 bits per bit.</p><p>Optimum compression would reduce the size
of this 838860800 bit file by 0 percent.</p><p>Chi square distribution for 838860800 samples is 0.62, and randomly would exceed this value 43.12 percent of the times.</p><p>Arithmetic mean value of data bits is 0.5000 (0.5 = random).</p><p>Monte Carlo value for Pi is 3.141913953 (error 0.01 percent).</p><p>Serial correlation coefficient is 0.000048 (totally uncorrelated = 0.0).</p></details><p>When applied to all three files, these are the results we get:</p><table><thead><tr><th>Type</th><th style=text-align:center>Chi Square</th><th style=text-align:center>Monte Carlo Difference</th><th style=text-align:center>Serial Correlation Coefficient</th></tr></thead><tbody><tr><td>Quantum</td><td style=text-align:center>1.41</td><td style=text-align:center>0.000280202</td><td style=text-align:center>-0.000014</td></tr><tr><td>Avalanche Diode</td><td style=text-align:center>3.09</td><td style=text-align:center>-0.000187861</td><td style=text-align:center>-0.000027</td></tr><tr><td>Pseudorandom Generator</td><td style=text-align:center>0.62</td><td style=text-align:center>-0.000321299</td><td style=text-align:center>0.000048</td></tr></tbody></table><p>We know that the <abbr title="Pseudorandom Number Generator">PRNG</abbr> is the least random, so if there are any tests that the PRNG does best, that test can not be used.</p><p>Unsurprisingly, the PRNG performs worst in every test. Avalanche diode outperforms quantum in Chi Square <em>and</em> estimating Pi. Quantum only outperformed Avalanche diode in Serial Correlation Coefficient. Since the goal is to observe convergence of randomness, serial correlation makes the most sense to use.</p><p>What we&rsquo;ll do now is observe the serial correlation coefficients of quantum and avalanche diode as the number of trials increases.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define MAX_READ 2500
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>double</span> array[<span style=color:#ae81ff>2</span>][MAX_READ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>analyzeFile</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>filename, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> filenum) {
</span></span><span style=display:flex><span>  FILE <span style=color:#f92672>*</span>f;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// I increased the array sizes because a memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// leak and I didn&#39;t care to track it down
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span> output[<span style=color:#ae81ff>1035</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> path[<span style=color:#ae81ff>1000</span>];
</span></span><span style=display:flex><span>  snprintf(path, <span style=color:#66d9ef>sizeof</span>(path), <span style=color:#e6db74>&#34;%s%s%s&#34;</span>, <span style=color:#e6db74>&#34;dd if=&#34;</span>, filename, <span style=color:#e6db74>&#34; bs=&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> bytes <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; bytes <span style=color:#f92672>&lt;=</span> MAX_READ; bytes<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> byteString[<span style=color:#ae81ff>21</span>];
</span></span><span style=display:flex><span>    snprintf(byteString, <span style=color:#ae81ff>21</span>, <span style=color:#e6db74>&#34;%lu&#34;</span>, bytes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> command[<span style=color:#ae81ff>2560</span>];
</span></span><span style=display:flex><span>    snprintf(command, <span style=color:#66d9ef>sizeof</span>(command), <span style=color:#e6db74>&#34;%s%s%s&#34;</span>, path, byteString,
</span></span><span style=display:flex><span>             <span style=color:#e6db74>&#34; count=8 iflag=fullblock 2&gt;/dev/null | ent -b | tail &#34;</span>
</span></span><span style=display:flex><span>             <span style=color:#e6db74>&#34;-1 | cut -c 35-43 | xargs&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    f <span style=color:#f92672>=</span> popen(command, <span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (fgets(output, <span style=color:#66d9ef>sizeof</span>(output), f) <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>      array[filenum][bytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> strtold(output, NULL);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  analyzeFile(<span style=color:#e6db74>&#34;../../randomReports/quantum&#34;</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  analyzeFile(<span style=color:#e6db74>&#34;../../randomReports/avalanche&#34;</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#e6db74>&#34;Theoretical Coefficient,Quantum Coefficient,Avalanche Diode &#34;</span>
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#34;Coefficient</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> line <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; line <span style=color:#f92672>&lt;</span> MAX_READ; line<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;0,%Lf,%Lf</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, array[<span style=color:#ae81ff>0</span>][line], array[<span style=color:#ae81ff>1</span>][line]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, much like before, we&rsquo;ll pipe this output into gnuplot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcc -c -o main.o main.c <span style=color:#f92672>&amp;&amp;</span> gcc ./main.o -o main <span style=color:#f92672>&amp;&amp;</span> ./main | cat &gt; /tmp/gnuplotdata.csv <span style=color:#f92672>&amp;&amp;</span> gnuplot -p -e <span style=color:#e6db74>&#34;set title &#39;Quantum vs. Avalanche&#39;;set xlabel &#39;Size (Bytes)&#39;;set ylabel &#39;Serial Correlation Coefficient&#39;;set datafile separator &#39;,&#39;;plot for [col=1:3] &#39;/tmp/gnuplotdata.csv&#39; using col with lines title columnheader;pause -1&#34;</span>
</span></span></code></pre></div><p><img src=../../images/randomCoefficients.webp alt="Gnuplot Coefficient Convergence Plot"></p><p>Well, this is interesting.</p><h2 id=explanation>Explanation</h2><p>I have a couple theories for why these two methods of <abbr title="True Random Number Generation">TRNG</abbr> approach correlation coefficients of 0 at different rates.</p><ol><li>Partial Measurements<ul><li>In a more <abbr title="more interactions to achieve the same goal">complex</abbr> system, there are more opportunities to be entangled with the environment which might increase correlation between measurements.</li></ul></li><li>Faulty Hardware<ul><li>The hardware might have some issue which causes data correlation</li></ul></li></ol><p>Obviously, the first explanation is more flashy, so I&rsquo;m hoping something along those lines is occurring. With the avalanche diode method, electrons will be entangled with the enclosure which is weakly entangled with everything around it. This additional entanglement could reduce the randomness of the sequence. Quantum methods of generation should, therefore, have varying rates of discorrelation based on their amounts of interaction with the environment.</p><p>I&rsquo;ll try to compare these rates with more precise avalanche diode machines and superconducting, photonic, nuclear magnetic resonance, dot, and other quantum methods.</p></article></main><footer><small>Thanks to <a href=https://gohugo.io/>Hugo</a> for building and <a href=https://simplecss.org/>SimpleCSS</a>
for styling
â™¡</small></footer></body></html>